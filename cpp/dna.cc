////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# include <iostream>
# include <vector>
# include <string>
# include <algorithm>
# include <climits>
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
template <typename T>
ostream& operator <<( ostream& os, const vector <T> & vec )
{
    os << "[";
    int n = vec.size();
    for( size_t j = 0; j < n; ++j ){
        cout << (( j > 0 ) ? ", " : " " ) << vec[ j ];
    }
    return os << (( n == 0 ) ? "]" : " ]" );
}    
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# define ALPHABETSIZ 26
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
typedef long long long_t;
////////////////////////////////////////////////////////////////
class Trie {
public:
    long_t          total;
    vector <int>    keys;
    vector <long_t> psum; // partial sum
    vector <Trie*>  chill;
    Trie(): chill( ALPHABETSIZ, nullptr )
    {
        total = 0;
    }
    void insert( int offset, const string& gene, int health );
};
////////////////////////////////////////////////////////////////
# define pos( C ) (( C ) - 'a' )
////////////////////////////////////////////////////////////////
void Trie:: insert( int offset, const string& gene, int health )
{
    Trie* node = this;
    for( char c: gene ){
        int p = pos( c );
        if( node->chill[ p ] == nullptr ){
            node->chill[ p ] = new Trie();
        }
        node = node->chill[ p ];
    }
    node->total += health;
    node->keys.push_back( offset );
    node->psum.push_back( node->total );
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//      return the position of the fyorst element of the array a
//                     greater than or equal to the value of key
int binsearch_f( int key, const vector <int> & a )
{
    int l = 0;
    int u = a.size() - 1;
    while( l <= u ){
        int m = ( l + u ) / 2;
        if( a[ m ] < key ){
            l = m + 1;
        } else {
            u = m - 1;
        }
    }
    return l;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//        return the position of the last element of the array a
//                        less than or equal to the value of key
int binsearch_l( int key, const vector <int> & a )
{
    int l = 0;
    int u = a.size() - 1;
    while( l <= u ){
        int m = ( l + u ) / 2;
        if( a[ m ] <= key ){
            l = m + 1;
        } else {
            u = m - 1;
        }
    }
    return u;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
class DNA {
public:
    const vector <string> & genes;
    const vector <int> & health;
    Trie* trie;
    DNA( const vector <string> & genes,
         const vector <int> & health )
        : genes( genes ),
          health( health )
    {
        trie = new Trie();
        int n = genes.size();
        for( int j = 0; j < n; ++j ){
            trie->insert( j, genes[ j ], health[ j ]);
        }
    }
    long_t get_total_health( int start, int finish,
                             const string& dna );
};
long_t DNA::get_total_health( int start, int finish,
                              const string& dna ){
    long_t total = 0;
    int n = dna.size();
    for( int j = 0; j < n; ++j ){
        Trie* node = trie;
        for( int i = j; i < n; ++i ){
            char key = pos( dna[ i ]);
            if( node->chill[ key ] == nullptr ) break;
            node = node->chill[ key ];
            const auto& a = node->keys;
            int f = binsearch_f( start, a );
            int l = binsearch_l( finish, a );
            if( f < a.size() and l >= 0 ){
                total += ( node->psum[ l ] -
                           node->psum[ f ] +
                           health[ a[ f ]]);
            }
        }
    }
    return total;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
string ltrim(const string &str){string s(str);s.erase(s.begin(),
find_if( s.begin(), s.end(), not1(ptr_fun<int, int>(isspace))));
return s;}//////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
string rtrim(const string &str){string s(str); s.erase(find_if(s
.rbegin(),s.rend(),not1(ptr_fun<int,int>(isspace))).base(),s.end
());return s;}//////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
vector<string>split(const string &str ){ vector< string >tokens;
string::size_type start=0;string::size_type end=0;while((end=str
.find(" ", start ))!=string::npos ){tokens.push_back(str.substr(
start,end-start));start=end+1;}tokens.push_back(str.substr(start
));return tokens;}//////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main(){ string n_temp;getline(cin,n_temp); int n=stoi(ltrim(
rtrim (  n_temp ) ) ) ; string genes_temp_temp ; getline ( cin ,
genes_temp_temp ) ;vector < string > genes_temp = split ( rtrim(
genes_temp_temp)) ; vector<string>genes(n);for(int i=0;i<n;i++){
string genes_item = genes_temp[ i ]; genes[i]=genes_item;}string
health_temp_temp; getline( cin,health_temp_temp );vector<string>
health_temp=split(rtrim(health_temp_temp)); vector<int>health(n)
; for ( int i = 0;i<n;i++){int health_item=stoi(health_temp[i]);
health[i]=health_item;}/////////////////////////////////////////
    DNA dna( genes, health );
    long_t min_health = LLONG_MAX;
    long_t max_health = LLONG_MIN;
string s_temp;getline(cin,s_temp);int s=stoi(ltrim(rtrim(s_temp)
)  )  ;  for  ( int  s_itr = 0 ; s_itr < s ; s_itr ++ ) { string 
first_multiple_input_temp;getline(cin,first_multiple_input_temp)
;  vector  <  string  >  first_multiple_input  = split ( rtrim (
first_multiple_input_temp));int first=stoi(first_multiple_input[
0 ] ) ; int last = stoi ( first_multiple_input [ 1 ] );string d=
first_multiple_input[2];////////////////////////////////////////
        long_t tot = dna.get_total_health( first, last, d );
        min_health = min( min_health, tot );
        max_health = max( max_health, tot );
    }
    cout << min_health << " " << max_health << endl;
}///////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// This problem is insane it uses binary search partial sums and
// tries, tha'ts a non trivial hard problem, I had to rewrite it
// in c++ cos there were some weird runtime errors in Python wow
// what is this? In situations like that I have no other options
// then to raise my finger and say something wise, khm, khm, ...
// I can give you guarantee there is no problem if we lose faith
// in our religion, it's bullshit anyway, but there is a problem
// if we lose faith in ourselves
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Points:                                        1174.21 / 2200
// Rank:                                                  133322 
