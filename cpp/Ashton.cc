////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////   /////////////////////////////////////////////////
////////////   /////////////////////////////////   ///////  ////
////////////   /////                 ///////////   /////////////
////. . .|.|.|.|.|.|.    @@@@@@@@@@@//////@@@/// fffffffffffffff
////     | | | | | |     @@@@@@@@@@/@@@///////// fffffffffffffff
////     | | |@@@@@|  @@@@@@@@@@@@@/@@@@@/@@@//@@@@@ff@@f@@@ffff S
////. . .|.|.@@@.@@@.@@@ @@@=@@@=///@@@///@@@/@@@f@@@f@@@f@@@fff 
////:a:a:|a|a@@@a|a|a@@@@@@@|@@@////@@@///@@@/@@@f@@@f@@@f@@@fff e 
////:a:a:|a|a|@@@@@|a@@@..@@@@@@////@@@///@@@/@@@f@@@f@@@f@@@fff  
////:a:a:|a|a|a|a@@@a@@@..@@@@@@////@@@///@@@/@@@f@@@f@@@f@@@fff ve
////:::::|:|:@@@:@@@:@@@..@@@@@@\\\\@@@\\\@@@\@@@f@@@f@@@f@@@fff
////:::::|:|  @@@@@   @@@@@   @@@@@  @@@@ @@@  @@@@@  @@@ @@@fff n
////.....|.|                                                ....
////.....|.|.|.|.|@|@@@@@@@@@@@@        ||||||||................
////=====|=|=|=|=|@|@@@@@@@@@@@@        ||||||||................
////|||||||||                                              .....
////=====|=|       |@@@@@@      @@@@||||      ||......      ....   
////||||||||       |@@@@@@      @@@@||||      ||......      ....   
////=====|=|       |,`,`,`      ____||||      ||______      ____  
////||||||||       |,`,`,`                    ||______      ____
////=====|=|       |,`,`,`      ____||||      ||______      ____
////.....|.|       |,`,`,`      ____||||      ||______      ____
////.....|.|       |######      ____||||      ||______      ____
////#####|#|       |######                    ||______      ____
////#####|#|       |######      ____||||      ||______      ____
////#####|#|       |######      ####||||      ||######      ____
////#####|#|       |######      ####||||      ||######      ####
////#####|#|#                                              #####
////#####|#|#|#|#|#|################||||||||||||################
////.....|.|.|/|/|/|/ / / / / / / / ||||||||||||/ / / / / / / / 
////=====|=|=| | | | / / / / / / / /|||||||||||| / / / / / / / /   
////////  ///// //////////////     ///           ///////////////    
////////  ////////////////////////////           /////        //
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Сектор 7, невидимото звено на клъстера „Halsberg Labs“.
// Маскирани лица, окъпани в сиянието на контролните монитори,
// се сливаха в ритъм с монотонното бръмчене на квантовия модул.
// Ключът бе тук. Някъде.
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# include <iostream>
# include <vector>
# include <string>
# include <algorithm>
# include <utility>
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
template <typename T>
ostream& operator<<( ostream& os, const vector<T>& vec ){
    string sep = "";
    for( const auto& value: vec ){
        os << sep << value;
        sep = " ";
    }
    return os;
}
////////////////////////////////////////////////////////////////
typedef long long i64;
////////////////////////////////////////////////////////////////
inline i64 f( int n ){
    return 1LL * n * (n + 1) / 2;
}
////////////////////////////////////////////////////////////////
//  1 23 456 789a bcdef
// |c|ca|cac|caca|cacao|
// 0 1  3   6   10    15
// 0 1  2   3    4     5
//  c ca cac caca cacao
////////////////////////////////////////////////////////////////
int binsrch( int sz, i64 k ){
    int l = 0;
    int u = sz - 1;
    while( l <= u ){
        int m = (l + u)/ 2;
        if( k <= f( m )){
            u = m - 1;
        } else {
            l = m + 1;
        }
    }
    return k - f(u) - 1;
    //
}
////////////////////////////////////////////////////////////////
//       0 1 2 3 4 5 6 i=0 "a" a; 1
//   s = b a n a n a @ i=1 "ana" x|an|ana; 6
//   p = 5 3 1 0 4 2   i=2 "anana" x|xx|xxx|anan|anana; 15
// lcp = 0 1 3 0 0 2   i=3 "banana" b|ba|ban|bana|banan|banana; 36
//                     i=4 "na" n|na; 39
//                     i=5 "nana" x|xx|nan|nana; 46
////////////////////////////////////////////////////////////////
char We_have_you_on_visual( const string& s, i64 k,
                            const vector<int>& p,
                            const vector<int>& lcp ){
    const size_t n = s.size();
    i64 total_p = 0;
    size_t j = 0;
    for( ; j < n; ++j ){
        int subsz = n - p[j];
        int cross = lcp[j];
        i64 total = total_p + f( subsz ) - f( cross );
        if( k <= total ) break;
        total_p = total;
    }
    int sz = n - p[j];
    k -= total_p - f( lcp[j] );
    int off = binsrch( sz, k );
    return s[p[j] + off];
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////####////
// hackerrank.com/challenges/ashton-and-string/         ####
////////////////////////////////////////////////////////####////
////////////////////////////////////////////////////////####////
char ashtonString( string&s, int k ); ///               ####
////////////////////////////////////////////////////////####////
////////////////////////////////////////////////////////####////
int main() {//                                          ####
    int t; cin >> t;
    while( t-- ){
        string s; cin >> s;
        int k; cin >> k;                           ////
        cout << ashtonString( s, k ) << endl;     ////
    }                                            ////
}                                               ////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// き れ い な 写 真
// 京 都 で き れ い な 写 真 を 撮 り ま し た 。
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
class SuffixArray {
public:
    const static int ALPHASQUAD = '{';
    //
    static int mod( int n, int m ){
        int r = n % m;
        return r < 0 ? r + m : r;
    }
    static vector<int> cons( string& s ){
        s += "@";
        SuffixArray sa( s );
        sa.build();
        s.pop_back();
        auto& p = sa.p;
        return { p.begin() + 1, p.end() };
    }
    //
    const int n;
    const string& s;
    int clasz;
    vector<int> p;
    vector<int> c;
    //
    SuffixArray( const string& s ):
        n( s.size() ),
        s( s ),
        p( vector<int>( n )),
        c( vector<int>( n ))
    {
    }
    ////////////////////////////////////////////////////////////
    void initialize() {
        vector<int> cnt( ALPHASQUAD );
        for( char ch: s ) ++cnt[ch];
        for( int j = 1; j < ALPHASQUAD; ++j ){
            cnt[j] += cnt[j - 1];
        }

        for( int i = n - 1; i >= 0; --i ){
            p[--cnt[s[i]]] = i;
        }
        clasz = 1;
        for( int i = 1; i < n; ++i ){
            if( s[p[i]] != s[p[i - 1]] ){
                ++clasz;
            }
            c[p[i]] = clasz - 1;
        }
    }
    void build() {
        initialize();
        for( int halflife = 1; halflife < n; halflife *= 2 ){
            build( halflife );
        }
    }
    ////////////////////////////////////////////////////////////////
    void build( int halflife ){
        vector<int> pn( n );
        for( int i = 0; i < n; ++i ){
            pn[i] = mod( p[i] - halflife, n );
        }
        vector<int> cnt( clasz );
        for( int j = 0; j < n; ++j ){
            ++cnt[c[j]];
        }
        for( int j = 1; j < clasz; ++j ){
            cnt[j] += cnt[j - 1];
        }
        for( int j = n - 1; j >= 0; --j ){
            p[--cnt[c[pn[j]]]] = pn[j];
        }

        vector<int> cn( n );
        clasz = 1;
        for( int i = 1; i < n; ++i ){
            pair<int,int> cur = {
                c[p[i]],
                c[mod( p[i] + halflife, n )]
            };
            pair<int,int> prev = {
                c[p[i - 1]],
                c[mod( p[i - 1] + halflife, n )]
            };
            if( cur != prev ) ++clasz;
            cn[p[i]] = clasz - 1;
        }
        c.swap( cn );
    }
};
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
vector<int> lcp_cons( const string& s, const vector<int>& p ){
    const int n = s.size();
    
    vector<int> rank( n );
    for( int i = 0; i < n; i++ ){
        rank[p[i]] = i;
    }
    int k = 0;
    vector<int> lcp( n - 1 );
    for( int i = 0; i < n; i++ ){
        if( rank[i] + 1 >= n ){
            k = 0;
            continue;
        }
        // s[j:] is lexicographically next after s[i:]
        int j = p[rank[i] + 1];
        while( i + k < n && j + k < n && s[i + k] == s[j + k]){
            k++;
        }
        lcp[rank[i]] = k;
        if( k ) k--;
    }
    return lcp;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
char ashtonString( string& s, int k ){
    vector<int> p = SuffixArray::cons( s );
    vector<int> lcp = lcp_cons( s, p );
    lcp.insert( lcp.begin(), 0 );
    return We_have_you_on_visual( s, k, p, lcp );
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Challenges:                                         162 / 563
// Rank:                                                    6310
// Points:                                                  4683
// Hackos:                                                  2417
// Score:                                                    100
