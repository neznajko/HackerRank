////////////////////////////////////////////////////////////////
// www.hackerrank.com/challenges/insertion-sort/problem
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# include <iostream>
# include <string>
# include <vector>
# include <algorithm>
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
string ltrim(const string&str){string s(str); s.erase(s.begin(),
find_if( s.begin(), s.end(),not1( ptr_fun <int,int>(isspace))));
return s;}//////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
string rtrim( const string&str ){string s(str);s.erase(find_if(s
.rbegin(), s.rend(), not1(ptr_fun <int,int>(isspace ))).base(),s
.end());return s;}//////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
vector<string> split( const string&str){ vector <string> tokens;
string::size_type start = 0;string::size_type end = 0;while((end
=str.find(" ",start))!=string::npos){tokens.push_back(str.substr
(start,end-start)); start = end+1;} tokens.push_back(str.substr(
start));return tokens;}/////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
typedef enum { RED, BLACK } color_t;
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
typedef long long i64;
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
class Node {
public:
    int key;
    i64 count;
    i64 ryte_count;
    Node* left;
    Node* ryte;
    color_t color;
    Node( int key )
        : key( key ),
          count( 1 ),
          ryte_count( 0 ),
          left( nullptr ),
          ryte( nullptr ),
          color( RED )          
    {}
    void flip() {
        color = RED;
        left->color = ryte->color = BLACK;
    }
};
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
inline bool isred( Node* node ){
    return ! node ? false : node->color == RED;
}
////////////////////////////////////////////////////////////////
inline bool isblack( Node* node ){
    return ! isred( node );
}
////////////////////////////////////////////////////////////////
Node* rotate_left( Node* h ){
    Node* x = h->ryte;
    h->ryte = x->left;
    x->left = h;
    x->color = h->color;
    h->color = RED;
    h->ryte_count -= x->count + x->ryte_count;
    return x;
}
////////////////////////////////////////////////////////////////
Node* rotate_ryte( Node* h ){
    Node* x = h->left;
    h->left = x->ryte;
    x->ryte = h;
    x->color = h->color;
    h->color = RED;
    x->ryte_count += h->count + h->ryte_count;
    return x;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// バス停 Bushaltestelle
// 病院 Krankenhaus
// ホテル Hotel
// 本屋 Buchhandlung
// 町 Stadt
// レストラン Restaurant
////////////////////////////////////////////////////////////////
Node* insert_coin( Node* node, int key, i64& ryte_count )
{
    ryte_count = 0;
    if( ! node ) return new Node( key );
    if( key == node->key ){
        ++node->count;
        ryte_count = node->ryte_count;
    } else if( key > node->key ){
        ++node->ryte_count;
        node->ryte = insert_coin( node->ryte, key, ryte_count );
    } else {
        node->left = insert_coin( node->left, key, ryte_count );
        ryte_count += node->count + node->ryte_count;
    }
    //
    if( isred( node->ryte ) and isblack( node->left )){
        node = rotate_left( node );
    }
    if( isred( node->left ) and isred( node->left->left )){
        node = rotate_ryte( node );
    }
    if( isred( node->left ) and isred( node->ryte )){
        node->flip();
    }
    //
    return node;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
i64 insertionSort( const vector <int> & a )
{
    Node* root = nullptr;
    i64 n = 0;
    i64 ryte_count = 0;
    for( int key: a ){
        root = insert_coin( root, key, ryte_count );
        n += ryte_count;
    }
    return n;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main(){string t_temp;getline(cin,t_temp);int t = stoi(ltrim(
trim(t_temp))); for(int t_itr=0;t_itr<t;t_itr++){string n_temp;
getline(cin,n_temp);int n = stoi(ltrim( rtrim( n_temp )));string 
arr_temp_temp;getline(cin,arr_temp_temp);vector<string>arr_temp=
split(rtrim(arr_temp_temp));vector<int> arr(n);for(int i=0;i<n;i
++){int arr_item=stoi(arr_temp[i]);arr[ i]=arr_item;}i64 result=
insertionSort(arr);cout<<result<<"\n";}}////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Hackos:                                                  1229
// Max Score:                                              50.00
// Points:                                        1594.21 / 2200
// Rank:                                                   80983
