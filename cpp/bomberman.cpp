////////////////////////////////////////////////////////////////
// www.hackerrank.com/challenges/bomber-man/problem
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# include                                             <iostream>
# include                                               <string>
# include                                               <vector>
# include                                            <algorithm>
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
string ltrim( const string&str){string s(str);s.erase(s.begin(),
find_if(s.begin(),s.end(),not1(ptr_fun<int,int>( isspace ) ) ));
return s;}//////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
string rtrim(const string &str){string s(str);s.erase(find_if(s.
rbegin(),s.rend(),not1(ptr_fun<int,int>(isspace))).base(),s.end(
));return s;}///////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
vector<string>split( const string & str ){ vector<string>tokens;
string::size_type start=0;string::size_type end=0;while((end=str
.find(" ",start)) !=string::npos ){ tokens.push_back(str.substr(
start,end-start));start=end+1;}tokens.push_back(str.substr(start
));return tokens;}//////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
inline bool isodd( int n ){ return n & 1; }
////////////////////////////////////////////////////////////////
inline bool isevn( int n ){ return ! isodd( n ); }
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
ostream& operator <<( ostream& _ , const vector <string> & g ){
    for( const auto& rank: g ){
        _ << rank << endl;
    }
    return _ ;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
const char VOID                                           = '.';
const char CROSS                                          = 'X';
const char BIGO                                           = 'O';
const char BOMB[]                             = { CROSS, BIGO };
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
bool equal( const vector <string> &a, const vector <string> &b )
{
    int n = a.size();
    int m = a[ 0 ].length();
    
    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < m; ++j ){
            char c = a[ i ][ j ];
            char d = b[ i ][ j ];
            if( c == VOID and d != VOID ) return false;
            if( d == VOID and c != VOID ) return false;
        }
    }
    return true;    
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
class Bombe {
private:
    int n;
    int m;
    vector <string> & grid;
    vector <vector <string>> cache;
public:
    Bombe( vector <string> & grid )
    : grid( grid )
    {
        n = grid.size();
        m = grid[ 0 ].size();
        cache.push_back( grid );
    }
    vector <string> full() {
        string rank( m, BIGO );
        return vector <string> ( n, rank );
    }
    void fill( char bomb ){
        for( int i = 0; i < n; ++i ){
            for( int j = 0; j < m; ++j ){
                if( grid[ i ][ j ] == VOID ){
                    grid[ i ][ j ] = bomb;
                }
            }
        }
    }
    void clear( int i, int j, char bomb ){
        grid[ i ][ j ] = VOID;
        if( i - 1 >= 0 ){
            grid[ i - 1 ][ j ] = VOID;
        }
        if( i + 1 < n and grid[ i + 1 ][ j ] != bomb ){
            grid[ i + 1 ][ j ] = VOID;
        }
        if( j - 1 >= 0 ){
            grid[ i ][ j - 1 ] = VOID;
        }
        if( j + 1 < m and grid[ i ][ j + 1 ] != bomb ){
            grid[ i ][ j + 1 ] = VOID;
        }
    }
    void detonate( char bomb ){
        for( int i = 0; i < n; ++i ){
            for( int j = 0; j < m; ++j ){
                if( grid[ i ][ j ] == bomb ){
                    clear( i, j, bomb );
                }
            }
        }
    }
    void push() {
        cache.push_back( grid );
    }
    vector <string> & get_answer( int j ){
        auto& g = j < 0 ? grid : cache[ j ];
        // X -> O
        for( int i = 0; i < n; ++i ){
            for( int j = 0; j < m; ++j ){
                if( g[ i ][ j ] == CROSS ){
                    g[ i ][ j ] = BIGO;
                }
            }
        }
        return g;
    }
    int check(){
        int siz = cache.size();
        for( int k = 0; k < siz; ++k ){
            if( equal( grid, cache[ k ])){
                return k;
            }
        }
        return -1;
    }
    friend ostream&
    operator <<( ostream& _ , const Bombe& bombe ){
        return _ << bombe.grid;
    }
};
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////@@@@@@@@@@@@@@@@@///////////////////////////////////////
////////@@@@@ @@@@@@@@@@@///////////////////////////////////////
////////   @        @@@@@///////////////////////////////////////
//////// *  ** **********/////|||||||||||||||||||||/////////////
////////   ***     ******/////|         |         |/////////////
//////// @ @@@ @@@@@@@@@@/////|    |    |    |    |/////////////
////////   @@@     @@@@@@/////|         |         |/////////////
////////@@@@@@ @@@@@@@@@@/////|    |    |    |    |/////////////
//////////////////////////////|         |         |/////////////
//////////////////////////////|    |||||||||||    |/////////////
//////////////////////////////|    |         |    |/////////////
//////////////////////////////|    |    |    |    |/////////////
//////////////////////////////|    |         |    |/////////////
//////////////////////////////|    |    |    |    |/////////////
//////////////////////////////|    |         |    |/////////////
//////////////////////////////|||||||||||||||||||||/////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//// きのう 昨日 : gestern :
//// じかん 時間 , Uhr ,
////////////////////////////////////////////////////////////////
//// せんじゅう 先週 ' letzte Woche '
//// とき 時 \ zeit \
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//// ///////////////////////////////////////////////////////////
//// ///////////////////////////////////////////////////////////
//// ///////////////////////////////////////////////////////////
//// ///////////////////////////////////////////////////////////
//// ///////////////////////////////////////////////////////////
vector <string> bomberMan( int nsec, vector <string> & grid )
{
    if( nsec <= 1 ) return grid;
    Bombe bombe( grid );
    if( isevn( nsec )) return bombe.full();
    for( int t = 2; t <= nsec; ++t ){
        int svitch = t / 2 & 1;
        if( isevn( t )){            
            bombe.fill( BOMB[ 1 - svitch ]);
        } else {
            bombe.detonate( BOMB[ svitch ]);
            int k0 = bombe.check();
            if( k0 >= 0 ){
                int k = ( t - 1 )/ 2;
                int mod = k - k0;
                int kn = ( nsec - 1 )/ 2;
                int j = k0 + ( kn - k0 ) % mod;
                return bombe.get_answer( j );
            }
            bombe.push();
        }
    }
    return bombe.get_answer( -1 );
}                                
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main () { string first_multiple_input_temp ; getline ( cin ,
first_multiple_input_temp);vector<string> first_multiple_input =
split ( rtrim ( first_multiple_input_temp )  )  ; int r = stoi (
first_multiple_input[0]);int c=stoi(first_multiple_input[1]);int
n=stoi(first_multiple_input[2]);vector<string>grid(r);for(int i=
0; i < r; i++ ){string grid_item;getline(cin,grid_item);grid[i]=
grid_item;}vector<string>result=bomberMan(n,grid);for(size_t i=0
;i<result.size(); i++ ){ cout<<result[i];if(i!=result.size()-1){
cout<<"\n";}}}//////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Hackos:                                                  1287
// Max Score:                                              40.00
// Points:                                        1618.21 / 2200
// Rank:                                                   78977
