////////////////////////////////////////////////////////////////
// hackerrank.com/challenges/manasa-and-stones/
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# include                                             <iostream>
# include                                               <string>
# include                                               <vector>
# include                                            <algorithm>
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
string ltrim( const string&str){string s(str);s.erase(s.begin(),
find_if(s.begin(),s.end(),not1(ptr_fun<int,int>( isspace ) ) ));
return s;}//////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
string rtrim(const string &str){string s(str);s.erase(find_if(s.
rbegin(),s.rend(),not1(ptr_fun<int,int>(isspace))).base(),s.end(
));return s;}///////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
vector<string>split( const string & str ){ vector<string>tokens;
string::size_type start=0;string::size_type end=0;while((end=str
.find(" ",start)) !=string::npos ){ tokens.push_back(str.substr(
start,end-start));start=end+1;}tokens.push_back(str.substr(start
));return tokens;}//////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
template <typename T>
ostream& operator <<( ostream& _ , const vector <T> & vec ){
    _ << "[";
    if( vec.size() > 0 ){
        _ << " ";
        for( const auto& y: vec ){
            _ << y << " ";
        }
    }
    return _ << "]";
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// > n=3 a=1 b=2
// 0 + 1 + 1 = 2                                             1 1
// 0 + 1 + 2 = 3                                             1 2
// 0 + 2 + 1 = 3                                             2 2
// 0 + 2 + 2 = 4
// < [ 2 3 4 ]
////////////////////////////////////////////////////////////////
// > n=4 a=10 b=100
// 0 + 10 + 10 + 10 = 30
// 0 + 10 + 10 + 100 = 120
// 0 + 10 + 100 + 10 = 120                        b - a = 90
// 0 + 10 + 100 + 100 = 210
// 0 + 100 + 10 + 10 = 120
// 0 + 100 + 10 + 100 = 210                       10  10  10  30 +90
// 0 + 100 + 100 + 10 = 210                       10  10 100 120 +90
// 0 + 100 + 100 + 100 = 300                      10 100 100 210 +90
// < [ 30 120 210 300 ]                          100 100 100 300
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
vector <int> stones( int n, int a, int b ){
    if( a > b ) swap( a, b );
    vector <int> stones = { a * ( n - 1 )};
    const int dif = b - a;
    if( dif ){
        for( int j = n - 1; j > 0; --j ){
            stones.push_back( stones.back() + dif );
        }
    }
    return stones;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main(){string T_temp; getline( cin,T_temp);int T=stoi(ltrim(
rtrim(T_temp)));for(int T_itr=0;T_itr <T;T_itr++){string n_temp;
getline(cin,n_temp);int n=stoi( ltrim( rtrim( n_temp ))); string 
a_temp;getline(cin,a_temp);int a = stoi( ltrim( rtrim(a_temp)));
string b_temp;getline(cin,b_temp);int b=stoi(ltrim(rtrim(b_temp)
));vector<int>result=stones(n,a,b);for(size_t i=0;i<result.size(
);i++){cout<<result[i];if(i!=result.size()-1){cout<<" ";}}cout<<
"\n";}}/////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Hackos:                                                  1806
// Score:                                                     30
// Rank:                                                   27451
// Challenges:                                          98 / 563
// Points:                                                  2613
// ◊ 1.3.18*. In a spherical hollow a ball jumps elastically
// between two points located on a same horizontal. The time
// between two hits from left to ryte is T₁ and from ryte to
// left T₂, T₂ ≠ T₁. What is the hollow's radius?
// #############################################################
// #############################################################
// #############################################################
// #############################################################
// ########      |              T₁->                   #########
// ########    g v              .                      #########
// ########              .              .              #########
// ##########               .        .               ###########
// ##########       . .       <-T₂         . .       ###########
// ############   ..                          ..   #############
// ##############.                              .###############
// ##################                        ###################
// #######################              ########################
// #############################################################
// #############################################################
// #################            ################################
// #############                    ############################
// ###########                        ##########################
// #########                            ########################
// #######                                ### ∡ OSB = ∡ OSA =: ф
// #######                                ### ∡ SOH =: ζ         
// #####                                    ####################
// #####                 O      A           ####################
// #####         B       .     `            ####################
// #####           `     | .    `           ####################
// #####              `  |   .   `          ####################
// #####                 |     .  `         ####################
// #######               |  `    . `      ######################
// #######               |     `   .`     ######################
// #########             |        `  .  ########################
// ###########           |         S  ##########################
// #############         |          ############################
// #################     H      ################################
// #############################################################
// #############################################################
// #############################################################
//
// vsin(ζ-ф)T₁ = vsin(ζ+ф)T₂ from horizontal projections, zo
// sin(ζ-ф)T₁ = sin(ζ+ф)T₂
// vcos(ζ-ф) - g(T₁|2) = 0
// vcos(ζ+ф) - g(T₂|2) = 0, from vertical projections, zo
// cos(ζ-ф)T₂ = cos(ζ+ф)T₁
//
// sin(ζ-ф)T₁ = sin(ζ+ф)T₂                                   (a)
// cos(ζ-ф)T₂ = cos(ζ+ф)T₁, zo                               (b)
//
// sin(ζ-ф) = sin(ζ+ф)(T₂|T₁)
// cos(ζ-ф) = cos(ζ+ф)(T₁|T₂)
// k := T₂|T₁
// 1 = sin²(ζ+ф)k² + cos²(ζ+ф)(1|k²)
// k² = sin²(ζ+ф)k⁴ + cos²(ζ+ф) = 
//    = sin²(ζ+ф)k⁴ + 1 - sin²(ζ+ф) =
//    = sin²(ζ+ф)[k⁴ - 1] + 1, zo
// sin²(ζ+ф) = (k² - 1)|(k⁴ - 1) = 1|(k² + 1)
// sin(ζ+ф) = 1|√(k² + 1)                                    (1)
// cos(ζ+ф) = k|√(k² + 1), zo                                (2)
// v = gT₂|2cos(ζ+ф) = gT₂√(k² + 1)|2k =
//   = g√(T₁² + T₂²)|2
// I think we have to find ζ now, let's write a similar
// expression for ζ-ф as (1) and (2) then we can use a
// trigonomeric formula for 2ζ = (ζ + ф) + (ζ - ф)
// it looks from (a) and (b) that we can change k -> 1/k in
// (1) and (2), so without further ado let's try with:
// sin(ζ-ф) = k|√(k² + 1)                                    (3)
// cos(ζ-ф) = 1|√(k² + 1)                                    (4)
// ok we have thus: cos(a + b) = cos(a)cos(b) – sin(a)sin(b), zo
// cos(2ζ) = cos(ζ + ф)cos(ζ - ф) - sin(ζ + ф)sin(ζ - ф) = 
//         = k|(k² + 1) - k|(k² + 1) = 0, zo ζ = 45°
// x := vsin(ζ-ф)T₁|2, R² = 2x², R = vsin(ζ-ф)T₁|(√2) =
// = v[k|√(k² + 1)]T₁|(√2) = v[ T₂T₁√(T₁² + T₂²)]|(√2) =
// = gT₂T₁|2√2                                                 «
////////////////////////////////////////////////////////////////
