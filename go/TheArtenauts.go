////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.`.
//
//
//    
//    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//    ;                                
//    ;                                
//    ;  ;;;;;;  ;;;;;;;;;;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//    ;  ;;          ;;              ;                          
//#####  ##          ##              ###########################
//#####  ##  ######  ##  ##########  ###########################
//#####  ##          ##              ###########################
//#####  ##          ##              ###########################
//#####  ##  ######  ##  ##########  ###########################
//#####  ##          ##              ###########################
//|||||  ||          ||              ||||||||||||||||||||||||| 
//|||||  ||||||  ||||||  ||||||||||  ||||||||||||||||||||||||||| T h
//|||||  |||  |  |  |||              ||||||||||||||||||||||||||| e  
//|||||  |||  |  |  |||              ||||||||||||||||||||||||||| A r
//||||  |||  ||  ||  ||||  ||||||  ||||||||||||||||||||||||||||| t e
//||||  |||  ||  |||||       ||     |||||||||||||||||||||||||||| n a
//___  ________  __       ______      __________________________ u t
//____________  _____  ___________  ____________________________ s
//______________________________________________________________ 
//______________________________________________________________ 
//____________@@_____@@___________@@____________________________
//___@@________@@__@@@@@@@______@@@@@@__________________________
//____@@___@@__@@_____@@@@@@@__@@@@@____________________________
//____@@___@@__@@__@@____@@______@@_____________________________
//_____@@___@@_@@_@@___@@@@@@@@@@@@@@___________________________
////////////////////////////////////////////////////////////////
//「願」— 3 セ ッ ト 8 回 [ Молитва ] - 3 серии по 8 повторения
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// hackerrank.com/challenges/journey-to-the-moon/
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
package main
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
import (
    "bufio"
    "fmt"
    "os"
    "strconv"
    "strings"
)
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
type i32 = int32
type u8 = uint8
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
const (
    FALSE u8 = 0
    TRUE  u8 = 1
)
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// 46. Let A¹, A²,..., Aⁿ be events. Let Bᵏ be the event exactly
// k of the Aⁱ occur, and Cᵏ be the event that at least k of the
// Aⁱ occur, f o r 0 ≤ k ≤ n. Find a simple expression for P(Bᵏ)
// in terms of P(Cᵏ) and P(Cᵏ⁺¹)
//
// Zo the e v e n t s Bᵏ are disjoint and Cᵏ = Bᵏ + ... + Bⁿ and
// Cᵏ⁺¹ = Bᵏ⁺¹ + ... + Bⁿ, where + means ∪ for disjoint sets, zo
// P(Bᵏ) = P(Cᵏ) - P(Cᵏ⁺¹)                                     «
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// 47. Events A a n d B a r e independent if P(A ∩ B) = P(A)P(B)
// (independence is explored in d e t a i l in the next chapter)
//
// (a) Give an example of independent events A and B in a finite
// sample space S (with neither equal t o Ø or S) and illustrate
// it with a Pebble World diagram.
//
// This is not very original b u t let's say we toss a fair coin
// and roll a fair die simultaneously or one a  f  t  e  r other:
// {H,T}         | Let A is the e v e n t the coin is Tails, and
// {1,2,3,4,5,6} | B is we h a v e rolled a number ≥ 3, this i s
// the sample space in Pebble World:
// +----+----+----+----+----+----+----+ , by counting we can see
// | H1 | H2 | H3 | H4 | H5 | H6 | H7 | t h a t P(A) = 1/2 a n d
// +----+----+----+----+----+----+----+ P( B ) = 2 / 3 Asterisks
// | T1 | T2 | T3 | T4*| T5*| T6*| T7*| mark the e v e n t A ∩ B
// +----+----+----+----+----+----+----+ i   t   s probability is:
// P(A ∩ B) = 4/12 = 1/3, zo A and B are independent b e c  o  z
// P(A)P(B) = 1/2 * 2/3 = 1/3 = P(A ∩ B)
//
// (b) Consider the experiment o f picking a random point in the
// rectangle R = {(x, y): 0 < x < 1, 0 < y < 1}, w h e r e t h e
// probability of t h e point b e i n g in any particular region
// contained within R i s the area of that region. Let A₁ and B₁
// be rectangles contained within R, with areas n o t equal to 0
// or 1. Let A be the event that the random point i s in A₁, and
// B be the event that the random p  o  i  n  t is in B₁. Give a
// geometric description of w h e n it i s true that A and B are
// independent. Also, give an example where they are independent
// and another example where they are not independent.
//
// +-------------------------------+ A r e A₁ and B₁ independent?
// |  +-------+                    | I n physical world when two
// |  | A₁    |         +------+   | things are overlapping each
// |  +-------+         | B₁   |   | other w e usually associate
// |  +----------+      |      |   | t h i s with some form o  f 
// |  | A₂    x  |      +------+   | interaction but o    u    r 
// |  |     +---------+            | natural intuition m i g h t
// |  |   y |||||| B₂ |            | deceive u s here cos A₁ and
// |  +-----+---------+            | B₁ are maximum dependent on
// +-------------------------------+ each other, t h e reason is
//                                   that if B₁ happens w e know 
// for sure that A₁ has not h a p p e n and vice v e r s a so by
// independence here we mean t h a t observing B will not affect
// the possibility of observing A, i f B happens that reduce the
// sample space to B, so A can happen only if A ∩ B happens, and
// the probability o f A when B has happen is P(A ∩ B)/P(B), cos
// we have to take into account the reduced sample space, z o if
// P(A) = P(A ∩ B)/P(B), that i s P(A ∩ B) = P(A)P(B) the events
// A and B are independent. I was w r o n g l y thinking that in
// quantum mechanics for example interaction i s equivalent with
// two wave function crossing each o t h e r, and I'm happy with
// this p r o b l e m becoz at least i t has cleared one of mine
// misunderstandings. In physics w   e can associate interaction
// not with intersection but with the lack of independence, like
// if the w a v e function of a system o f two object ψ₁₂ can be
// represented as t h e product ψ₁ψ₂ t h e r e is no interaction,
// something like this
//
// (c) S  h  o  w that if A and B are independent, then P(A ∪ B)
// = P(A) + P(B) − P(A)P(B) = 1 − P(Aᶜ)P(Bᶜ)
//
// Here we c a n use t h e inclusion e x c l u s i o n principle:
// P(A ∪ B) = P(A) + P(B) - P(A ∩ B) = P(A) + P(B) - P(A)P(B) = 
// = P(A) + P(B) - (1 - P(Aᶜ)(1 - P(Bᶜ)) = P(A) + P(B) - 1
// + P(Aᶜ) + P(Bᶜ) - P(Aᶜ)P(Bᶜ) = 1 - P(Aᶜ)P(Bᶜ)               «
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
type Graph struct {
    n i32
    adj [][]i32
    vztd []u8
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
func NewGraph( n i32, artenauts [][]i32 ) *Graph {

    adj := make( [][]i32, n )
    for _, pair := range artenauts {
        i, j := pair[0], pair[1]
        adj[i] = append( adj[i], j )
        adj[j] = append( adj[j], i )
    }
    return &Graph {
        n:   n,
        adj: adj,
        vztd: make( []u8, n ),
    }
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
func ( g *Graph ) Debug() {
    fmt.Println( "Number of vertices:", g.n )
    fmt.Println( "Adjacency list:", g.adj )
    fmt.Println( "Vizited array:", g.vztd )
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
func ( g *Graph ) Dfs() [][]i32 {
    var teams [][]int32
    for i := i32( 0 ); i < g.n; i++ {
        if g.vztd[i] == FALSE {
            teams = append( teams, g.explore( i ))
        }
    }
    return teams
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
func ( g *Graph ) explore( i i32 ) []i32 {
    g.vztd[i] = TRUE
    team := []i32{ i }
    for _, j := range g.adj[i] {
        if g.vztd[j] == FALSE {
            team = append( team, g.explore( j )... )
        }
    }
    return team
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
func nfpairs( teams [][]i32 ) int {
    nfteams := len( teams )
    total := 0
    sum := len( teams[ nfteams - 1 ])
    for j:= nfteams - 2; j >= 0; j -- {
        total += len( teams[j] ) * sum
        sum += len( teams[j] )
    }
    return total
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
func journeyToMoon( n i32, artenauts [][]i32 ) int {
    g := NewGraph( n, artenauts )
    var teams = g.Dfs()
    return nfpairs( teams )
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// > 19. [20] If n is an integer whose decimal representation is
// 14 digits l o n g, will the value of n fit in a computer word
// with a capacity of 47 bits and a sign bit?
//
// Ok if we have a number w i t h value n what namba of bits are
// required in general? 8 in binary i    s 1000 and is 2³, 16 iz
// 10000 and iz 2⁴, zo a l l numbers in between like 15..9 needs
// only 4 b i t s, zo number in binary system, can be written az:
// n = aᵢ2ⁱ + aᵢ₋₁2ⁱ⁻¹ + ... + a₁2¹ + a₀2⁰, w e can think aᵢ = 1,
// z  o lg n = i + 0.something, that is i = floor( lg n ), hence
// n requires i + 1 = floor( lg n ) + 1 bits; i  f n is 2 digits
// long the maximum v a l u e will be 99, but we can effectively
// take i  t  s value to be 100, o r in general case of k-length
// digit 10^k, be coz 10^k can't be represented as 10000...00000
// in binary that is 10^k = 2^m for some m, be coz the ryte hand
// side is not divisible by f  a  i. That is k-lenght long digit
// will require floor( lg 10^k ) + 1 = floor( k lg 10 ) + 1, for
// k = 14 we have floor( 14 * 3.321928094887362 ) + 1 = 47     «
//////////////////////////////////////////////////////////////// ˡ
//////////////////////////////////////////////////////////////// ᵏ
func main(){//////////////////////////////////////////////////// ʲ
    reader:=bufio.NewReader(os.Stdin)/////////////////////////// ⁱ
    line,_:=reader.ReadString('\n')///////////////////////////// ʰ
    parts:=strings.Fields(line)///////////////////////////////// ᵍ
    n,_:=strconv.ParseInt(parts[0],10,32)/////////////////////// ᶠ
    p,_:=strconv.ParseInt(parts[1],10,32)/////////////////////// ᵉ
    artenauts:=make([][]int32,0,p)////////////////////////////// ᵈ
    for i:=int64(0);i<p;i++{//////////////////////////////////// ᶜ
        line,_=reader.ReadString('\n')////////////////////////// ᵇ
        parts=strings.Fields(line)////////////////////////////// ᵃ
        a,_:=strconv.ParseInt(parts[0],10,32)/////////////////// ⁿ
        b,_:=strconv.ParseInt(parts[1],10,32)/////////////////// ⁱ
        artenauts=append(artenauts,[]int32{int32(a),int32(b)})// ⁾
    }/////////////////////////////////////////////////////////// ⁽
    result:=journeyToMoon(int32(n),artenauts)/////////////////// ⁼
    fmt.Println(result)///////////////////////////////////////// ⁻
}/////////////////////////////////////////////////////////////// ⁺
//////////////////////////////////////////////////////////////// ⁹
//////////////////////////////////////////////////////////////// ⁸
//////////////////////////////////////////////////////////////// ⁷
//////////////////////////////////////////////////////////////// ⁶
//////////////////////////////////////////////////////////////// ⁵
//////////////////////////////////////////////////////////////// ⁴
//////////////////////////////////////////////////////////////// ³
//////////////////////////////////////////////////////////////// ²
//////////////////////////////////////////////////////////////// ¹
//////////////////////////////////////////////////////////////// ⁰
// Challenges:                                         158 / 563 
// Rank:                                                    7167
// Points:                                                  4438
// Score:                                                     50
// Hackos:                                                  2324
