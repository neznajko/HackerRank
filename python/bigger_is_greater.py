################################################################
# hackerrank.com/challenges/bigger-is-greater/problem
################################################################
################################################################
################################################################
################################################################
# This algorithm is similar to the algorithm of generating all
# permutations in lexicographical order from Knuth books, the
# idea is as follows: starting from the rear we look for the fst
# occurance of this pattern:
#
#       #            where w[ j - 1 ] < w[ j ], then in the
#       # #          range [ j, n - 1 ] we look for the mosryte
#       # #          element w[ i ] greater then w[ j - 1 ] in
#     # # #          this case w[ i ] = e, and swap i and j - 1,
#     # # # #        last we reverse the [ j, n - 1 ] range so
#  .. # # # # #      to be in increasing order
#       j i   n - 1 
#  .. c f e b a
#
#       #                      #  This is lexicographicaly the
#     # #              #       #  next permutation after
#     # #              #       #  .. c f e b a
#     # # #            #     # #
#     # # # #          #   # # #
#  .. # # # # #     .. # # # # #
#  .. e f c b a     .. e a b c f
#
#  after swapping   after reversing
################################################################
################################################################
################################################################
################################################################
def find_i( w, j ):
    n = len( w )
    i = j + 1
    while i < n and w[ i ] > w[ j - 1 ]:
        i += 1
    return i - 1
################################################################
################################################################
################################################################
################################################################
def reverse( w, i ):
    j = len( w ) - 1
    while i < j:
        w[ i ], w[ j ] = w[ j ], w[ i ]
        i += 1
        j -= 1    
################################################################
################################################################
################################################################
################################################################
def biggerIsGreater( w ):
    w = list( w )
    j = len( w ) - 1
    while j > 0:
        if w[ j ] > w[ j - 1 ]:
            i = find_i( w, j )
            w[ i ], w[ j - 1 ] = w[ j - 1 ], w[ i ]
            reverse( w, j )
            return ''.join( w )
        j -= 1
    return "no answer"
################################################################
################################################################
################################################################
################################################################
if __name__=='__main__': #######################################
    T=int(input().strip()) #####################################
    for T_itr in range(T): #####################################
        w=input() ##############################################
        result=biggerIsGreater(w) ##############################
        print(result) ##########################################
################################################################
################################################################
################################################################
################################################################
# Hackos:                                                   1599
# Max Score:                                               35.00
# Points:                                         2008.21 / 2200
# Rank:                                                    55592
